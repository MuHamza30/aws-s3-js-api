/**
 * AWS S3Lib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiResponse, RequestOptions } from '../core.js';
import {
  ListBucketResult1,
  listBucketResult1Schema,
} from '../models/listBucketResult1.js';
import { number, string, unknown } from '../schema.js';
import { BaseController } from './baseController.js';
import { ApiError } from '@apimatic/core';

export class ObjectsController extends BaseController {
  /**
   * The HEAD operation retrieves metadata from an object without returning the object itself. This
   * operation is useful if you're only interested in an object's metadata. To use HEAD, you must have
   * READ access to the object.
   *
   * @param partNumber
   * @param versionId
   * @param xAmzContentSha256
   * @param bucket
   * @param key
   * @return Response from the API call
   */
  async object(
    partNumber: string,
    versionId: string,
    xAmzContentSha256: string,
    bucket: string,
    key: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      partNumber: [partNumber, string()],
      versionId: [versionId, string()],
      xAmzContentSha256: [xAmzContentSha256, string()],
      bucket: [bucket, string()],
      key: [key, string()],
    });
    req.header('x-amz-content-sha256', mapped.xAmzContentSha256);
    req.query('PartNumber', mapped.partNumber);
    req.query('VersionId', mapped.versionId);
    req.appendTemplatePath`/${mapped.bucket}/${mapped.key}`;
    req.throwOn(400, ApiError, 'Bad Request');
    return req.call(requestOptions);
  }

  /**
   * Returns some or all (up to 1000) of the objects in a bucket. You can use the request parameters as
   * selection criteria to return a subset of the objects in a bucket. A 200 OK response can contain
   * valid or invalid XML. Be sure to design your application to parse the contents of the response and
   * handle it appropriately.
   *
   * @param delimiter
   * @param encodingType
   * @param marker
   * @param maxKeys
   * @param prefix
   * @param xAmzContentSha256
   * @param bucket
   * @return Response from the API call
   */
  async objectsV1(
    delimiter: string,
    encodingType: string,
    marker: string,
    maxKeys: string,
    prefix: string,
    xAmzContentSha256: string,
    bucket: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<ListBucketResult1>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      delimiter: [delimiter, string()],
      encodingType: [encodingType, string()],
      marker: [marker, string()],
      maxKeys: [maxKeys, string()],
      prefix: [prefix, string()],
      xAmzContentSha256: [xAmzContentSha256, string()],
      bucket: [bucket, string()],
    });
    req.header('x-amz-content-sha256', mapped.xAmzContentSha256);
    req.query('Delimiter', mapped.delimiter);
    req.query('EncodingType', mapped.encodingType);
    req.query('Marker', mapped.marker);
    req.query('MaxKeys', mapped.maxKeys);
    req.query('Prefix', mapped.prefix);
    req.appendTemplatePath`/${mapped.bucket}`;
    return req.callAsXml(
      'ListBucketResult',
      listBucketResult1Schema,
      requestOptions
    );
  }

  /**
   * Returns some or all (up to 1000) of the objects in a bucket. You can use the request parameters as
   * selection criteria to return a subset of the objects in a bucket. A 200 OK response can contain
   * valid or invalid XML. Be sure to design your application to parse the contents of the response and
   * handle it appropriately.
   *
   * @param listType
   * @param continuationToken
   * @param delimiter
   * @param encodingType
   * @param fetchOwner
   * @param maxKeys
   * @param prefix
   * @param startAfter
   * @param xAmzContentSha256
   * @param bucket
   * @return Response from the API call
   */
  async objectsV2(
    listType: number,
    continuationToken: string,
    delimiter: string,
    encodingType: string,
    fetchOwner: string,
    maxKeys: string,
    prefix: string,
    startAfter: string,
    xAmzContentSha256: string,
    bucket: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      listType: [listType, number()],
      continuationToken: [continuationToken, string()],
      delimiter: [delimiter, string()],
      encodingType: [encodingType, string()],
      fetchOwner: [fetchOwner, string()],
      maxKeys: [maxKeys, string()],
      prefix: [prefix, string()],
      startAfter: [startAfter, string()],
      xAmzContentSha256: [xAmzContentSha256, string()],
      bucket: [bucket, string()],
    });
    req.header('x-amz-content-sha256', mapped.xAmzContentSha256);
    req.query('list-type', mapped.listType);
    req.query('ContinuationToken', mapped.continuationToken);
    req.query('Delimiter', mapped.delimiter);
    req.query('EncodingType', mapped.encodingType);
    req.query('FetchOwner', mapped.fetchOwner);
    req.query('MaxKeys', mapped.maxKeys);
    req.query('Prefix', mapped.prefix);
    req.query('StartAfter', mapped.startAfter);
    req.appendTemplatePath`/${mapped.bucket}`;
    return req.call(requestOptions);
  }

  /**
   * Retrieves objects from Amazon S3. To use GET, you must have READ access to the object. If you grant
   * READ access to the anonymous user, you can return the object without using an authorization header.
   *
   * @param xAmzContentSha256
   * @param bucket
   * @param key
   * @return Response from the API call
   */
  async object1(
    xAmzContentSha256: string,
    bucket: string,
    key: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      xAmzContentSha256: [xAmzContentSha256, string()],
      bucket: [bucket, string()],
      key: [key, string()],
    });
    req.header('x-amz-content-sha256', mapped.xAmzContentSha256);
    req.appendTemplatePath`/${mapped.bucket}/${mapped.key}`;
    return req.call(requestOptions);
  }

  /**
   * Lists the parts that have been uploaded for a specific multipart upload. This operation must include
   * the upload ID, which you obtain by sending the initiate multipart upload request (see
   * CreateMultipartUpload). This request returns a maximum of 1,000 uploaded parts. The default number
   * of parts returned is 1,000 parts. You can restrict the number of parts returned by specifying the
   * max-parts request parameter. If your multipart upload consists of more than 1,000 parts, the
   * response returns an IsTruncated field with the value of true, and a NextPartNumberMarker element. In
   * subsequent ListParts requests you can include the part-number-marker query string parameter and set
   * its value to the NextPartNumberMarker field value from the previous response.
   *
   * @param maxParts
   * @param partNumberMarker
   * @param uploadId
   * @param xAmzContentSha256
   * @param bucket
   * @param key
   * @return Response from the API call
   */
  async parts(
    maxParts: string,
    partNumberMarker: string,
    uploadId: string,
    xAmzContentSha256: string,
    bucket: string,
    key: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      maxParts: [maxParts, string()],
      partNumberMarker: [partNumberMarker, string()],
      uploadId: [uploadId, string()],
      xAmzContentSha256: [xAmzContentSha256, string()],
      bucket: [bucket, string()],
      key: [key, string()],
    });
    req.header('x-amz-content-sha256', mapped.xAmzContentSha256);
    req.query('MaxParts', mapped.maxParts);
    req.query('PartNumberMarker', mapped.partNumberMarker);
    req.query('UploadId', mapped.uploadId);
    req.appendTemplatePath`/${mapped.bucket}/${mapped.key}`;
    return req.call(requestOptions);
  }

  /**
   * Creates a copy of an object that is already stored in Amazon S3.
   *
   * @param xAmzContentSha256
   * @param body
   * @param bucket
   * @param key
   * @return Response from the API call
   */
  async copyObject(
    xAmzContentSha256: string,
    body: string,
    bucket: string,
    key: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<unknown>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      xAmzContentSha256: [xAmzContentSha256, string()],
      body: [body, string()],
      bucket: [bucket, string()],
      key: [key, string()],
    });
    req.header('x-amz-content-sha256', mapped.xAmzContentSha256);
    req.text(mapped.body);
    req.appendTemplatePath`/${mapped.bucket}/${mapped.key}/`;
    return req.callAsJson(unknown(), requestOptions);
  }

  /**
   * Removes the null version (if there is one) of an object and inserts a delete marker, which becomes
   * the latest version of the object. If there isn't a null version, Amazon S3 does not remove any
   * objects.
   *
   * @param versionId
   * @param xAmzContentSha256
   * @param bucket
   * @param key
   * @return Response from the API call
   */
  async deleteObject(
    versionId: string,
    xAmzContentSha256: string,
    bucket: string,
    key: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      versionId: [versionId, string()],
      xAmzContentSha256: [xAmzContentSha256, string()],
      bucket: [bucket, string()],
      key: [key, string()],
    });
    req.header('x-amz-content-sha256', mapped.xAmzContentSha256);
    req.query('VersionId', mapped.versionId);
    req.appendTemplatePath`/${mapped.bucket}/${mapped.key}`;
    return req.call(requestOptions);
  }

  /**
   * This operation enables you to delete multiple objects from a bucket using a single HTTP request. If
   * you know the object keys that you want to delete, then this operation provides a suitable
   * alternative to sending individual delete requests, reducing per-request overhead.
   *
   * @param mDelete
   * @param xAmzContentSha256
   * @param body
   * @param bucket
   * @return Response from the API call
   */
  async deleteObjects(
    mDelete: string,
    xAmzContentSha256: string,
    body: string,
    bucket: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<void>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({
      mDelete: [mDelete, string()],
      xAmzContentSha256: [xAmzContentSha256, string()],
      body: [body, string()],
      bucket: [bucket, string()],
    });
    req.header('x-amz-content-sha256', mapped.xAmzContentSha256);
    req.query('delete', mapped.mDelete);
    req.text(mapped.body);
    req.appendTemplatePath`/${mapped.bucket}`;
    return req.call(requestOptions);
  }
}
